import { GEMINI_API_KEY } from './env';
import { GoogleGenerativeAI } from "@google/generative-ai";

// Initialize the Google Generative AI with API key
const genAI = new GoogleGenerativeAI(GEMINI_API_KEY);

// In-memory storage for development
const questionsStore = {};

// Generate dynamic MCQ questions using Gemini API
export async function generateMCQQuestions() {
  console.log("generateMCQQuestions called - starting question generation");
  
  const prompt = `
    Generate 20 unique multiple-choice career assessment questions related to STEM fields (Science, Technology, Engineering, Mathematics).
    
    Current timestamp: ${Date.now()} - make these questions unique from any previous set.
    
    For each question:
    1. The question should deeply assess a person's interest, aptitude, or preference in career-related aspects.
    2. Provide exactly 4 answer choices (labeled A through D).
    3. Each answer choice should correspond to one of the four STEM categories: Science, Technology, Engineering, or Mathematics.
    4. Specify which STEM category each option belongs to.
    5. Make each question insightful for career guidance purposes.
    6. Ensure questions are diverse, covering different aspects of career preferences, work styles, problem-solving approaches, and interests.
    7. Questions should help identify a person's authentic career preferences in STEM fields.
    
    Format your response as a JSON object with the following structure:
    {
      "questions": [
        {
          "question": "Question text here",
          "options": [
            "A. Option text here",
            "B. Option text here",
            "C. Option text here",
            "D. Option text here"
          ],
          "categories": [
            "Science", 
            "Technology", 
            "Engineering", 
            "Mathematics"
          ],
          "responses": []
        }
      ]
    }
    
    Make the questions engaging, diverse, and relevant to career choices. Focus on preferences, interests, aptitudes, and work styles rather than technical knowledge.
  `;

  try {
    console.log("Attempting to call Gemini API with key:", GEMINI_API_KEY ? "Key present" : "No key found");
    
    // Make sure API key is available
    if (!GEMINI_API_KEY) {
      throw new Error("Gemini API key is required");
    }
    
    // Get the model (Gemini-1.5-Pro is a good choice for structured output)
    const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash" });

    // Set up the generation configuration
    const generationConfig = {
      temperature: 0.8,
      maxOutputTokens: 4000,
      responseMimeType: "application/json",
    };

    // Request data and structured output
    const result = await model.generateContent({
      contents: [{ role: "user", parts: [{ text: prompt }] }],
      generationConfig,
    });

    console.log("Gemini API response received");
    const response = result.response;
    const text = response.text();
    
    console.log("Raw API response:", text); // Add logging to see raw response
    
    try {
      // Clean up the response text to ensure valid JSON
      const cleanedText = text.trim()
        .replace(/\n/g, ' ')  // Remove newlines
        .replace(/\s+/g, ' ') // Normalize whitespace
        .replace(/,\s*([}\]])/g, '$1'); // Remove trailing commas
      
      console.log("Cleaned response text:", cleanedText);
      
      // Parse the JSON from the cleaned response
      const parsedQuestions = JSON.parse(cleanedText);
      
      // Validate the parsed response structure
      if (!parsedQuestions || typeof parsedQuestions !== 'object') {
        throw new Error('Invalid response format: not an object');
      }
      
      if (!Array.isArray(parsedQuestions.questions)) {
        throw new Error('Invalid response format: questions is not an array');
      }
      
      console.log(`Successfully generated ${parsedQuestions.questions.length} new career assessment questions`);
      
      // Ensure we have at least some questions
      if (parsedQuestions.questions.length < 5) {
        throw new Error("Not enough questions generated by the API");
      }
      
      // Add responses array to each question if not present
      parsedQuestions.questions.forEach(question => {
        if (!question.responses) {
          question.responses = [];
        }
      });
      
      // Generate a session ID
      const sessionId = Date.now().toString();
      
      // Store questions in memory
      questionsStore[sessionId] = parsedQuestions;
      
      // Return with session ID
      return { ...parsedQuestions, sessionId };
    } catch (parseError) {
      console.error("Error parsing Gemini response:", parseError);
      console.error("Response text:", text);
      throw new Error(`Failed to parse response from Gemini API: ${parseError.message}`);
    }
  } catch (error) {
    console.error("Error generating questions:", error);
    // Check if it's a quota exceeded error
    if (error.message && error.message.includes("RESOURCE_EXHAUSTED")) {
      throw new Error("Gemini API quota exhausted. Please try again later.");
    }
    throw error;
  }
}

// Function to save user response
export async function saveUserResponse(sessionId, questionIndex, selectedOptionIndex) {
  try {
    if (!questionsStore[sessionId]) {
      throw new Error(`Session not found: ${sessionId}`);
    }
    
    const questionsData = questionsStore[sessionId];
    
    if (!questionsData.questions[questionIndex]) {
      throw new Error(`Question not found at index ${questionIndex}`);
    }
    
    // Add the response
    if (!questionsData.questions[questionIndex].responses) {
      questionsData.questions[questionIndex].responses = [];
    }
    
    questionsData.questions[questionIndex].responses.push({
      optionIndex: selectedOptionIndex,
      timestamp: Date.now()
    });
    
    // Update in store
    questionsStore[sessionId] = questionsData;
    
    return true;
  } catch (error) {
    console.error("Error saving user response:", error);
    return false;
  }
}

// Function to get questions for a session
export async function getSessionQuestions(sessionId) {
  try {
    if (!questionsStore[sessionId]) {
      throw new Error(`Session not found: ${sessionId}`);
    }
    
    return { ...questionsStore[sessionId], sessionId };
  } catch (error) {
    console.error("Error getting session questions:", error);
    return null;
  }
} 